; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
; RUN: opt < %s -passes=instrumentor -S | FileCheck %s
define i32 @foo(i1 %c) {
; CHECK-LABEL: define i32 @foo(
; CHECK-SAME: i1 [[C:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*:]]
; CHECK-NEXT:    [[TMP0:%.*]] = alloca <{ i32, i32, [7 x i8], i1 }>, align 8
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[TMP0]], ptr @__instrumentor_value_pack, i64 16, i1 false)
; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds nuw <{ i32, i32, [7 x i8], i1 }>, ptr [[TMP0]], i32 0, i32 3
; CHECK-NEXT:    store i1 [[C]], ptr [[TMP3]], align 1
; CHECK-NEXT:    call void @__instrumentor_pre_function(ptr @foo, ptr @__instrumentor_.str, i32 1, ptr [[TMP0]]) #[[ATTR1:[0-9]+]]
; CHECK-NEXT:    [[TMP4:%.*]] = getelementptr inbounds i8, ptr [[TMP0]], i32 8
; CHECK-NEXT:    [[TMP5:%.*]] = load i1, ptr [[TMP4]], align 1
; CHECK-NEXT:    [[TMP6:%.*]] = zext i1 [[TMP5]] to i8
; CHECK-NEXT:    [[TMP7:%.*]] = call i8 @__instrumentor_pre_br(i8 1, i8 [[TMP6]], i64 2) #[[ATTR1]]
; CHECK-NEXT:    br i1 [[TMP5]], label %[[A:.*]], label %[[B:.*]]
; CHECK:       [[A]]:
; CHECK-NEXT:    ret i32 0
; CHECK:       [[B]]:
; CHECK-NEXT:    [[TMP8:%.*]] = call i8 @__instrumentor_pre_br(i8 0, i8 1, i64 1) #[[ATTR1]]
; CHECK-NEXT:    br label %[[D:.*]]
; CHECK:       [[D]]:
; CHECK-NEXT:    ret i32 1
;
entry:
  br i1 %c, label %a, label %b
a:
  ret i32 0
b:
  br label %d
d:
  ret i32 1
}
