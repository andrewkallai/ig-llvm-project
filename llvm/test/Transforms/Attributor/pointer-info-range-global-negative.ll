; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --check-attributes --check-globals
; RUN: opt -aa-pipeline=basic-aa -passes=attributor -attributor-manifest-internal  -attributor-annotate-decl-cs  -S < %s | FileCheck %s --check-prefixes=CHECK,TUNIT
; RUN: opt -aa-pipeline=basic-aa -passes=attributor-cgscc -attributor-manifest-internal  -attributor-annotate-decl-cs -S < %s | FileCheck %s --check-prefixes=CHECK,CGSCC

@A = internal global [101 x i32] zeroinitializer, align 4

;.
; CHECK: @A = internal global [101 x i32] zeroinitializer, align 4
;.
define i32 @range_no_overlap_a() {
; TUNIT: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(write)
; TUNIT-LABEL: define {{[^@]+}}@range_no_overlap_a
; TUNIT-SAME: () #[[ATTR0:[0-9]+]] {
; TUNIT-NEXT:  entry:
; TUNIT-NEXT:    store i32 3, ptr @A, align 4
; TUNIT-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; TUNIT-NEXT:    br label [[FOR_COND_I:%.*]]
; TUNIT:       for.cond.i:
; TUNIT-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; TUNIT-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; TUNIT-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10_EXIT:%.*]]
; TUNIT:       for.body.i:
; TUNIT-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[I_0_I]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 1), i64 [[IDXPROM_I]]
; TUNIT-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I]]
; TUNIT:       write10.exit:
; TUNIT-NEXT:    br label [[FOR_COND_I1:%.*]]
; TUNIT:       for.cond.i1:
; TUNIT-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10_EXIT]] ], [ [[INC_I7:%.*]], [[FOR_BODY_I4:%.*]] ]
; TUNIT-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; TUNIT-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10_EXIT8:%.*]]
; TUNIT:       for.body.i4:
; TUNIT-NEXT:    [[IDXPROM_I5:%.*]] = sext i32 [[I_0_I2]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I6:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 90), i64 [[IDXPROM_I5]]
; TUNIT-NEXT:    [[INC_I7]] = add nsw i32 [[I_0_I2]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I1]]
; TUNIT:       write10.exit8:
; TUNIT-NEXT:    ret i32 8
;
; CGSCC: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; CGSCC-LABEL: define {{[^@]+}}@range_no_overlap_a
; CGSCC-SAME: () #[[ATTR0:[0-9]+]] {
; CGSCC-NEXT:  entry:
; CGSCC-NEXT:    store i32 3, ptr @A, align 4
; CGSCC-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    br label [[FOR_COND_I:%.*]]
; CGSCC:       for.cond.i:
; CGSCC-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; CGSCC-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; CGSCC-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10_EXIT:%.*]]
; CGSCC:       for.body.i:
; CGSCC-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[I_0_I]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 1), i64 [[IDXPROM_I]]
; CGSCC-NEXT:    store i32 [[I_0_I]], ptr [[ARRAYIDX_I]], align 4
; CGSCC-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I]]
; CGSCC:       write10.exit:
; CGSCC-NEXT:    br label [[FOR_COND_I1:%.*]]
; CGSCC:       for.cond.i1:
; CGSCC-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10_EXIT]] ], [ [[INC_I7:%.*]], [[FOR_BODY_I4:%.*]] ]
; CGSCC-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; CGSCC-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10_EXIT8:%.*]]
; CGSCC:       for.body.i4:
; CGSCC-NEXT:    [[IDXPROM_I5:%.*]] = sext i32 [[I_0_I2]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I6:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 90), i64 [[IDXPROM_I5]]
; CGSCC-NEXT:    store i32 [[I_0_I2]], ptr [[ARRAYIDX_I6]], align 4
; CGSCC-NEXT:    [[INC_I7]] = add nsw i32 [[I_0_I2]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I1]]
; CGSCC:       write10.exit8:
; CGSCC-NEXT:    [[TMP0:%.*]] = load i32, ptr @A, align 4
; CGSCC-NEXT:    [[TMP1:%.*]] = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], [[TMP1]]
; CGSCC-NEXT:    ret i32 [[ADD]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.body.i, %entry
  %i.0.i = phi i32 [ 0, %entry ], [ %inc.i, %for.body.i ]
  %cmp.i = icmp slt i32 %i.0.i, 10
  br i1 %cmp.i, label %for.body.i, label %write10.exit

for.body.i:                                       ; preds = %for.cond.i
  %idxprom.i = sext i32 %i.0.i to i64
  %arrayidx.i = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 1), i64 %idxprom.i
  store i32 %i.0.i, ptr %arrayidx.i, align 4
  %inc.i = add nsw i32 %i.0.i, 1
  br label %for.cond.i

write10.exit:                                     ; preds = %for.cond.i
  br label %for.cond.i1

for.cond.i1:                                      ; preds = %for.body.i4, %write10.exit
  %i.0.i2 = phi i32 [ 0, %write10.exit ], [ %inc.i7, %for.body.i4 ]
  %cmp.i3 = icmp slt i32 %i.0.i2, 10
  br i1 %cmp.i3, label %for.body.i4, label %write10.exit8

for.body.i4:                                      ; preds = %for.cond.i1
  %idxprom.i5 = sext i32 %i.0.i2 to i64
  %arrayidx.i6 = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 90), i64 %idxprom.i5
  store i32 %i.0.i2, ptr %arrayidx.i6, align 4
  %inc.i7 = add nsw i32 %i.0.i2, 1
  br label %for.cond.i1

write10.exit8:                                    ; preds = %for.cond.i1
  %0 = load i32, ptr @A, align 4
  %1 = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  %add = add nsw i32 %0, %1
  ret i32 %add
}

define i32 @range_no_overlap_b() {
; TUNIT: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(write)
; TUNIT-LABEL: define {{[^@]+}}@range_no_overlap_b
; TUNIT-SAME: () #[[ATTR0]] {
; TUNIT-NEXT:  entry:
; TUNIT-NEXT:    store i32 3, ptr @A, align 4
; TUNIT-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; TUNIT-NEXT:    [[CALL:%.*]] = call ptr @get1Offset(ptr noalias nofree noundef nonnull readnone align 4 dereferenceable(404) "no-capture-maybe-returned" @A) #[[ATTR3:[0-9]+]]
; TUNIT-NEXT:    br label [[FOR_COND_I:%.*]]
; TUNIT:       for.cond.i:
; TUNIT-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; TUNIT-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; TUNIT-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10_EXIT:%.*]]
; TUNIT:       for.body.i:
; TUNIT-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[I_0_I]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr [[CALL]], i64 [[IDXPROM_I]]
; TUNIT-NEXT:    store i32 [[I_0_I]], ptr [[ARRAYIDX_I]], align 4
; TUNIT-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I]]
; TUNIT:       write10.exit:
; TUNIT-NEXT:    br label [[FOR_COND_I1:%.*]]
; TUNIT:       for.cond.i1:
; TUNIT-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10_EXIT]] ], [ [[INC_I7:%.*]], [[FOR_BODY_I4:%.*]] ]
; TUNIT-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; TUNIT-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10_EXIT8:%.*]]
; TUNIT:       for.body.i4:
; TUNIT-NEXT:    [[IDXPROM_I5:%.*]] = sext i32 [[I_0_I2]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I6:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 90), i64 [[IDXPROM_I5]]
; TUNIT-NEXT:    [[INC_I7]] = add nsw i32 [[I_0_I2]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I1]]
; TUNIT:       write10.exit8:
; TUNIT-NEXT:    ret i32 8
;
; CGSCC: Function Attrs: mustprogress nofree nosync nounwind willreturn
; CGSCC-LABEL: define {{[^@]+}}@range_no_overlap_b
; CGSCC-SAME: () #[[ATTR1:[0-9]+]] {
; CGSCC-NEXT:  entry:
; CGSCC-NEXT:    store i32 3, ptr @A, align 4
; CGSCC-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    [[CALL:%.*]] = call ptr @get1Offset(ptr noalias nofree noundef nonnull readnone align 4 dereferenceable(404) @A) #[[ATTR3:[0-9]+]]
; CGSCC-NEXT:    br label [[FOR_COND_I:%.*]]
; CGSCC:       for.cond.i:
; CGSCC-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; CGSCC-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; CGSCC-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10_EXIT:%.*]]
; CGSCC:       for.body.i:
; CGSCC-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[I_0_I]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr [[CALL]], i64 [[IDXPROM_I]]
; CGSCC-NEXT:    store i32 [[I_0_I]], ptr [[ARRAYIDX_I]], align 4
; CGSCC-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I]]
; CGSCC:       write10.exit:
; CGSCC-NEXT:    br label [[FOR_COND_I1:%.*]]
; CGSCC:       for.cond.i1:
; CGSCC-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10_EXIT]] ], [ [[INC_I7:%.*]], [[FOR_BODY_I4:%.*]] ]
; CGSCC-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; CGSCC-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10_EXIT8:%.*]]
; CGSCC:       for.body.i4:
; CGSCC-NEXT:    [[IDXPROM_I5:%.*]] = sext i32 [[I_0_I2]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I6:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 90), i64 [[IDXPROM_I5]]
; CGSCC-NEXT:    store i32 [[I_0_I2]], ptr [[ARRAYIDX_I6]], align 4
; CGSCC-NEXT:    [[INC_I7]] = add nsw i32 [[I_0_I2]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I1]]
; CGSCC:       write10.exit8:
; CGSCC-NEXT:    [[TMP0:%.*]] = load i32, ptr @A, align 4
; CGSCC-NEXT:    [[TMP1:%.*]] = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], [[TMP1]]
; CGSCC-NEXT:    ret i32 [[ADD]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  %call = call ptr @get1Offset(ptr noundef @A)
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.body.i, %entry
  %i.0.i = phi i32 [ 0, %entry ], [ %inc.i, %for.body.i ]
  %cmp.i = icmp slt i32 %i.0.i, 10
  br i1 %cmp.i, label %for.body.i, label %write10.exit

for.body.i:                                       ; preds = %for.cond.i
  %idxprom.i = sext i32 %i.0.i to i64
  %arrayidx.i = getelementptr inbounds i32, ptr %call, i64 %idxprom.i
  store i32 %i.0.i, ptr %arrayidx.i, align 4
  %inc.i = add nsw i32 %i.0.i, 1
  br label %for.cond.i

write10.exit:                                     ; preds = %for.cond.i
  br label %for.cond.i1

for.cond.i1:                                      ; preds = %for.body.i4, %write10.exit
  %i.0.i2 = phi i32 [ 0, %write10.exit ], [ %inc.i7, %for.body.i4 ]
  %cmp.i3 = icmp slt i32 %i.0.i2, 10
  br i1 %cmp.i3, label %for.body.i4, label %write10.exit8

for.body.i4:                                      ; preds = %for.cond.i1
  %idxprom.i5 = sext i32 %i.0.i2 to i64
  %arrayidx.i6 = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 90), i64 %idxprom.i5
  store i32 %i.0.i2, ptr %arrayidx.i6, align 4
  %inc.i7 = add nsw i32 %i.0.i2, 1
  br label %for.cond.i1

write10.exit8:                                    ; preds = %for.cond.i1
  %0 = load i32, ptr @A, align 4
  %1 = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  %add = add nsw i32 %0, %1
  ret i32 %add
}

define ptr @get1Offset(ptr noundef %P) {
; TUNIT: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
; TUNIT-LABEL: define {{[^@]+}}@get1Offset
; TUNIT-SAME: (ptr nofree noundef readnone "no-capture-maybe-returned" [[P:%.*]]) #[[ATTR1:[0-9]+]] {
; TUNIT-NEXT:  entry:
; TUNIT-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[P]], i64 1
; TUNIT-NEXT:    ret ptr [[ARRAYIDX]]
;
; CGSCC: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
; CGSCC-LABEL: define {{[^@]+}}@get1Offset
; CGSCC-SAME: (ptr nofree noundef readnone "no-capture-maybe-returned" [[P:%.*]]) #[[ATTR2:[0-9]+]] {
; CGSCC-NEXT:  entry:
; CGSCC-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[P]], i64 1
; CGSCC-NEXT:    ret ptr [[ARRAYIDX]]
;
entry:
  %arrayidx = getelementptr inbounds i32, ptr %P, i64 1
  ret ptr %arrayidx
}

define i32 @range_overlap_1_a() {
; TUNIT: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; TUNIT-LABEL: define {{[^@]+}}@range_overlap_1_a
; TUNIT-SAME: () #[[ATTR2:[0-9]+]] {
; TUNIT-NEXT:  entry:
; TUNIT-NEXT:    store i32 3, ptr @A, align 4
; TUNIT-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; TUNIT-NEXT:    br label [[FOR_COND_I:%.*]]
; TUNIT:       for.cond.i:
; TUNIT-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; TUNIT-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; TUNIT-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10_EXIT:%.*]]
; TUNIT:       for.body.i:
; TUNIT-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[I_0_I]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr @A, i64 [[IDXPROM_I]]
; TUNIT-NEXT:    store i32 [[I_0_I]], ptr [[ARRAYIDX_I]], align 4
; TUNIT-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I]]
; TUNIT:       write10.exit:
; TUNIT-NEXT:    br label [[FOR_COND_I1:%.*]]
; TUNIT:       for.cond.i1:
; TUNIT-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10_EXIT]] ], [ [[INC_I7:%.*]], [[FOR_BODY_I4:%.*]] ]
; TUNIT-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; TUNIT-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10_EXIT8:%.*]]
; TUNIT:       for.body.i4:
; TUNIT-NEXT:    [[IDXPROM_I5:%.*]] = sext i32 [[I_0_I2]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I6:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 90), i64 [[IDXPROM_I5]]
; TUNIT-NEXT:    [[INC_I7]] = add nsw i32 [[I_0_I2]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I1]]
; TUNIT:       write10.exit8:
; TUNIT-NEXT:    [[TMP0:%.*]] = load i32, ptr @A, align 4
; TUNIT-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], 5
; TUNIT-NEXT:    ret i32 [[ADD]]
;
; CGSCC: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; CGSCC-LABEL: define {{[^@]+}}@range_overlap_1_a
; CGSCC-SAME: () #[[ATTR0]] {
; CGSCC-NEXT:  entry:
; CGSCC-NEXT:    store i32 3, ptr @A, align 4
; CGSCC-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    br label [[FOR_COND_I:%.*]]
; CGSCC:       for.cond.i:
; CGSCC-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; CGSCC-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; CGSCC-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10_EXIT:%.*]]
; CGSCC:       for.body.i:
; CGSCC-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[I_0_I]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr @A, i64 [[IDXPROM_I]]
; CGSCC-NEXT:    store i32 [[I_0_I]], ptr [[ARRAYIDX_I]], align 4
; CGSCC-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I]]
; CGSCC:       write10.exit:
; CGSCC-NEXT:    br label [[FOR_COND_I1:%.*]]
; CGSCC:       for.cond.i1:
; CGSCC-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10_EXIT]] ], [ [[INC_I7:%.*]], [[FOR_BODY_I4:%.*]] ]
; CGSCC-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; CGSCC-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10_EXIT8:%.*]]
; CGSCC:       for.body.i4:
; CGSCC-NEXT:    [[IDXPROM_I5:%.*]] = sext i32 [[I_0_I2]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I6:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 90), i64 [[IDXPROM_I5]]
; CGSCC-NEXT:    store i32 [[I_0_I2]], ptr [[ARRAYIDX_I6]], align 4
; CGSCC-NEXT:    [[INC_I7]] = add nsw i32 [[I_0_I2]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I1]]
; CGSCC:       write10.exit8:
; CGSCC-NEXT:    [[TMP0:%.*]] = load i32, ptr @A, align 4
; CGSCC-NEXT:    [[TMP1:%.*]] = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], [[TMP1]]
; CGSCC-NEXT:    ret i32 [[ADD]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.body.i, %entry
  %i.0.i = phi i32 [ 0, %entry ], [ %inc.i, %for.body.i ]
  %cmp.i = icmp slt i32 %i.0.i, 10
  br i1 %cmp.i, label %for.body.i, label %write10.exit

for.body.i:                                       ; preds = %for.cond.i
  %idxprom.i = sext i32 %i.0.i to i64
  %arrayidx.i = getelementptr inbounds i32, ptr @A, i64 %idxprom.i
  store i32 %i.0.i, ptr %arrayidx.i, align 4
  %inc.i = add nsw i32 %i.0.i, 1
  br label %for.cond.i

write10.exit:                                     ; preds = %for.cond.i
  br label %for.cond.i1

for.cond.i1:                                      ; preds = %for.body.i4, %write10.exit
  %i.0.i2 = phi i32 [ 0, %write10.exit ], [ %inc.i7, %for.body.i4 ]
  %cmp.i3 = icmp slt i32 %i.0.i2, 10
  br i1 %cmp.i3, label %for.body.i4, label %write10.exit8

for.body.i4:                                      ; preds = %for.cond.i1
  %idxprom.i5 = sext i32 %i.0.i2 to i64
  %arrayidx.i6 = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 90), i64 %idxprom.i5
  store i32 %i.0.i2, ptr %arrayidx.i6, align 4
  %inc.i7 = add nsw i32 %i.0.i2, 1
  br label %for.cond.i1

write10.exit8:                                    ; preds = %for.cond.i1
  %0 = load i32, ptr @A, align 4
  %1 = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  %add = add nsw i32 %0, %1
  ret i32 %add
}

define i32 @range_overlap_1_b() {
; TUNIT: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; TUNIT-LABEL: define {{[^@]+}}@range_overlap_1_b
; TUNIT-SAME: () #[[ATTR2]] {
; TUNIT-NEXT:  entry:
; TUNIT-NEXT:    store i32 3, ptr @A, align 4
; TUNIT-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; TUNIT-NEXT:    br label [[FOR_COND_I:%.*]]
; TUNIT:       for.cond.i:
; TUNIT-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; TUNIT-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; TUNIT-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10_EXIT:%.*]]
; TUNIT:       for.body.i:
; TUNIT-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[I_0_I]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr @A, i64 [[IDXPROM_I]]
; TUNIT-NEXT:    store i32 [[I_0_I]], ptr [[ARRAYIDX_I]], align 4
; TUNIT-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I]]
; TUNIT:       write10.exit:
; TUNIT-NEXT:    br label [[FOR_COND_I1:%.*]]
; TUNIT:       for.cond.i1:
; TUNIT-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10_EXIT]] ], [ [[INC_I7:%.*]], [[FOR_BODY_I4:%.*]] ]
; TUNIT-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; TUNIT-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10_EXIT8:%.*]]
; TUNIT:       for.body.i4:
; TUNIT-NEXT:    [[IDXPROM_I5:%.*]] = sext i32 [[I_0_I2]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I6:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 90), i64 [[IDXPROM_I5]]
; TUNIT-NEXT:    [[INC_I7]] = add nsw i32 [[I_0_I2]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I1]]
; TUNIT:       write10.exit8:
; TUNIT-NEXT:    [[TMP0:%.*]] = load i32, ptr @A, align 4
; TUNIT-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], 5
; TUNIT-NEXT:    ret i32 [[ADD]]
;
; CGSCC: Function Attrs: mustprogress nofree nosync nounwind willreturn
; CGSCC-LABEL: define {{[^@]+}}@range_overlap_1_b
; CGSCC-SAME: () #[[ATTR1]] {
; CGSCC-NEXT:  entry:
; CGSCC-NEXT:    store i32 3, ptr @A, align 4
; CGSCC-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    br label [[FOR_COND_I:%.*]]
; CGSCC:       for.cond.i:
; CGSCC-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; CGSCC-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; CGSCC-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10_EXIT:%.*]]
; CGSCC:       for.body.i:
; CGSCC-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[I_0_I]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr @A, i64 [[IDXPROM_I]]
; CGSCC-NEXT:    store i32 [[I_0_I]], ptr [[ARRAYIDX_I]], align 4
; CGSCC-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I]]
; CGSCC:       write10.exit:
; CGSCC-NEXT:    br label [[FOR_COND_I1:%.*]]
; CGSCC:       for.cond.i1:
; CGSCC-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10_EXIT]] ], [ [[INC_I7:%.*]], [[FOR_BODY_I4:%.*]] ]
; CGSCC-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; CGSCC-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10_EXIT8:%.*]]
; CGSCC:       for.body.i4:
; CGSCC-NEXT:    [[IDXPROM_I5:%.*]] = sext i32 [[I_0_I2]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I6:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 90), i64 [[IDXPROM_I5]]
; CGSCC-NEXT:    store i32 [[I_0_I2]], ptr [[ARRAYIDX_I6]], align 4
; CGSCC-NEXT:    [[INC_I7]] = add nsw i32 [[I_0_I2]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I1]]
; CGSCC:       write10.exit8:
; CGSCC-NEXT:    [[TMP0:%.*]] = load i32, ptr @A, align 4
; CGSCC-NEXT:    [[TMP1:%.*]] = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], [[TMP1]]
; CGSCC-NEXT:    ret i32 [[ADD]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  %call = call ptr @get0Offset(ptr noundef @A)
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.body.i, %entry
  %i.0.i = phi i32 [ 0, %entry ], [ %inc.i, %for.body.i ]
  %cmp.i = icmp slt i32 %i.0.i, 10
  br i1 %cmp.i, label %for.body.i, label %write10.exit

for.body.i:                                       ; preds = %for.cond.i
  %idxprom.i = sext i32 %i.0.i to i64
  %arrayidx.i = getelementptr inbounds i32, ptr %call, i64 %idxprom.i
  store i32 %i.0.i, ptr %arrayidx.i, align 4
  %inc.i = add nsw i32 %i.0.i, 1
  br label %for.cond.i

write10.exit:                                     ; preds = %for.cond.i
  br label %for.cond.i1

for.cond.i1:                                      ; preds = %for.body.i4, %write10.exit
  %i.0.i2 = phi i32 [ 0, %write10.exit ], [ %inc.i7, %for.body.i4 ]
  %cmp.i3 = icmp slt i32 %i.0.i2, 10
  br i1 %cmp.i3, label %for.body.i4, label %write10.exit8

for.body.i4:                                      ; preds = %for.cond.i1
  %idxprom.i5 = sext i32 %i.0.i2 to i64
  %arrayidx.i6 = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 90), i64 %idxprom.i5
  store i32 %i.0.i2, ptr %arrayidx.i6, align 4
  %inc.i7 = add nsw i32 %i.0.i2, 1
  br label %for.cond.i1

write10.exit8:                                    ; preds = %for.cond.i1
  %0 = load i32, ptr @A, align 4
  %1 = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  %add = add nsw i32 %0, %1
  ret i32 %add
}

define ptr @get0Offset(ptr noundef %P) {
; TUNIT: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
; TUNIT-LABEL: define {{[^@]+}}@get0Offset
; TUNIT-SAME: (ptr nofree noundef readnone returned "no-capture-maybe-returned" [[P:%.*]]) #[[ATTR1]] {
; TUNIT-NEXT:  entry:
; TUNIT-NEXT:    ret ptr [[P]]
;
; CGSCC: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
; CGSCC-LABEL: define {{[^@]+}}@get0Offset
; CGSCC-SAME: (ptr nofree noundef readnone returned "no-capture-maybe-returned" [[P:%.*]]) #[[ATTR2]] {
; CGSCC-NEXT:  entry:
; CGSCC-NEXT:    ret ptr [[P]]
;
entry:
  %arrayidx = getelementptr inbounds i32, ptr %P, i64 0
  ret ptr %arrayidx
}

define i32 @range_overlap_2_a() {
; TUNIT: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; TUNIT-LABEL: define {{[^@]+}}@range_overlap_2_a
; TUNIT-SAME: () #[[ATTR2]] {
; TUNIT-NEXT:  entry:
; TUNIT-NEXT:    store i32 3, ptr @A, align 4
; TUNIT-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; TUNIT-NEXT:    br label [[FOR_COND_I:%.*]]
; TUNIT:       for.cond.i:
; TUNIT-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; TUNIT-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; TUNIT-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10_EXIT:%.*]]
; TUNIT:       for.body.i:
; TUNIT-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[I_0_I]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 1), i64 [[IDXPROM_I]]
; TUNIT-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I]]
; TUNIT:       write10.exit:
; TUNIT-NEXT:    br label [[FOR_COND_I1:%.*]]
; TUNIT:       for.cond.i1:
; TUNIT-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10_EXIT]] ], [ [[INC_I7:%.*]], [[FOR_BODY_I4:%.*]] ]
; TUNIT-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; TUNIT-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10_EXIT8:%.*]]
; TUNIT:       for.body.i4:
; TUNIT-NEXT:    [[IDXPROM_I5:%.*]] = sext i32 [[I_0_I2]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I6:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 91), i64 [[IDXPROM_I5]]
; TUNIT-NEXT:    store i32 [[I_0_I2]], ptr [[ARRAYIDX_I6]], align 4
; TUNIT-NEXT:    [[INC_I7]] = add nsw i32 [[I_0_I2]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I1]]
; TUNIT:       write10.exit8:
; TUNIT-NEXT:    [[TMP0:%.*]] = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; TUNIT-NEXT:    [[ADD:%.*]] = add nsw i32 3, [[TMP0]]
; TUNIT-NEXT:    ret i32 [[ADD]]
;
; CGSCC: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; CGSCC-LABEL: define {{[^@]+}}@range_overlap_2_a
; CGSCC-SAME: () #[[ATTR0]] {
; CGSCC-NEXT:  entry:
; CGSCC-NEXT:    store i32 3, ptr @A, align 4
; CGSCC-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    br label [[FOR_COND_I:%.*]]
; CGSCC:       for.cond.i:
; CGSCC-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; CGSCC-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; CGSCC-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10_EXIT:%.*]]
; CGSCC:       for.body.i:
; CGSCC-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[I_0_I]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 1), i64 [[IDXPROM_I]]
; CGSCC-NEXT:    store i32 [[I_0_I]], ptr [[ARRAYIDX_I]], align 4
; CGSCC-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I]]
; CGSCC:       write10.exit:
; CGSCC-NEXT:    br label [[FOR_COND_I1:%.*]]
; CGSCC:       for.cond.i1:
; CGSCC-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10_EXIT]] ], [ [[INC_I7:%.*]], [[FOR_BODY_I4:%.*]] ]
; CGSCC-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; CGSCC-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10_EXIT8:%.*]]
; CGSCC:       for.body.i4:
; CGSCC-NEXT:    [[IDXPROM_I5:%.*]] = sext i32 [[I_0_I2]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I6:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 91), i64 [[IDXPROM_I5]]
; CGSCC-NEXT:    store i32 [[I_0_I2]], ptr [[ARRAYIDX_I6]], align 4
; CGSCC-NEXT:    [[INC_I7]] = add nsw i32 [[I_0_I2]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I1]]
; CGSCC:       write10.exit8:
; CGSCC-NEXT:    [[TMP0:%.*]] = load i32, ptr @A, align 4
; CGSCC-NEXT:    [[TMP1:%.*]] = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], [[TMP1]]
; CGSCC-NEXT:    ret i32 [[ADD]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.body.i, %entry
  %i.0.i = phi i32 [ 0, %entry ], [ %inc.i, %for.body.i ]
  %cmp.i = icmp slt i32 %i.0.i, 10
  br i1 %cmp.i, label %for.body.i, label %write10.exit

for.body.i:                                       ; preds = %for.cond.i
  %idxprom.i = sext i32 %i.0.i to i64
  %arrayidx.i = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 1), i64 %idxprom.i
  store i32 %i.0.i, ptr %arrayidx.i, align 4
  %inc.i = add nsw i32 %i.0.i, 1
  br label %for.cond.i

write10.exit:                                     ; preds = %for.cond.i
  br label %for.cond.i1

for.cond.i1:                                      ; preds = %for.body.i4, %write10.exit
  %i.0.i2 = phi i32 [ 0, %write10.exit ], [ %inc.i7, %for.body.i4 ]
  %cmp.i3 = icmp slt i32 %i.0.i2, 10
  br i1 %cmp.i3, label %for.body.i4, label %write10.exit8

for.body.i4:                                      ; preds = %for.cond.i1
  %idxprom.i5 = sext i32 %i.0.i2 to i64
  %arrayidx.i6 = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 91), i64 %idxprom.i5
  store i32 %i.0.i2, ptr %arrayidx.i6, align 4
  %inc.i7 = add nsw i32 %i.0.i2, 1
  br label %for.cond.i1

write10.exit8:                                    ; preds = %for.cond.i1
  %0 = load i32, ptr @A, align 4
  %1 = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  %add = add nsw i32 %0, %1
  ret i32 %add
}

define i32 @range_overlap_2_b() {
; TUNIT: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; TUNIT-LABEL: define {{[^@]+}}@range_overlap_2_b
; TUNIT-SAME: () #[[ATTR2]] {
; TUNIT-NEXT:  entry:
; TUNIT-NEXT:    store i32 3, ptr @A, align 4
; TUNIT-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; TUNIT-NEXT:    [[CALL:%.*]] = call ptr @get1Offset(ptr noalias nofree noundef nonnull readnone align 4 dereferenceable(404) "no-capture-maybe-returned" @A) #[[ATTR3]]
; TUNIT-NEXT:    br label [[FOR_COND_I:%.*]]
; TUNIT:       for.cond.i:
; TUNIT-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; TUNIT-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; TUNIT-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10_EXIT:%.*]]
; TUNIT:       for.body.i:
; TUNIT-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[I_0_I]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr [[CALL]], i64 [[IDXPROM_I]]
; TUNIT-NEXT:    store i32 [[I_0_I]], ptr [[ARRAYIDX_I]], align 4
; TUNIT-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I]]
; TUNIT:       write10.exit:
; TUNIT-NEXT:    br label [[FOR_COND_I1:%.*]]
; TUNIT:       for.cond.i1:
; TUNIT-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10_EXIT]] ], [ [[INC_I7:%.*]], [[FOR_BODY_I4:%.*]] ]
; TUNIT-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; TUNIT-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10_EXIT8:%.*]]
; TUNIT:       for.body.i4:
; TUNIT-NEXT:    [[IDXPROM_I5:%.*]] = sext i32 [[I_0_I2]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I6:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 91), i64 [[IDXPROM_I5]]
; TUNIT-NEXT:    store i32 [[I_0_I2]], ptr [[ARRAYIDX_I6]], align 4
; TUNIT-NEXT:    [[INC_I7]] = add nsw i32 [[I_0_I2]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I1]]
; TUNIT:       write10.exit8:
; TUNIT-NEXT:    [[TMP0:%.*]] = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; TUNIT-NEXT:    [[ADD:%.*]] = add nsw i32 3, [[TMP0]]
; TUNIT-NEXT:    ret i32 [[ADD]]
;
; CGSCC: Function Attrs: mustprogress nofree nosync nounwind willreturn
; CGSCC-LABEL: define {{[^@]+}}@range_overlap_2_b
; CGSCC-SAME: () #[[ATTR1]] {
; CGSCC-NEXT:  entry:
; CGSCC-NEXT:    store i32 3, ptr @A, align 4
; CGSCC-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    [[CALL:%.*]] = call ptr @get1Offset(ptr noalias nofree noundef nonnull readnone align 4 dereferenceable(404) @A) #[[ATTR3]]
; CGSCC-NEXT:    br label [[FOR_COND_I:%.*]]
; CGSCC:       for.cond.i:
; CGSCC-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; CGSCC-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; CGSCC-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10_EXIT:%.*]]
; CGSCC:       for.body.i:
; CGSCC-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[I_0_I]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr [[CALL]], i64 [[IDXPROM_I]]
; CGSCC-NEXT:    store i32 [[I_0_I]], ptr [[ARRAYIDX_I]], align 4
; CGSCC-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I]]
; CGSCC:       write10.exit:
; CGSCC-NEXT:    br label [[FOR_COND_I1:%.*]]
; CGSCC:       for.cond.i1:
; CGSCC-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10_EXIT]] ], [ [[INC_I7:%.*]], [[FOR_BODY_I4:%.*]] ]
; CGSCC-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; CGSCC-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10_EXIT8:%.*]]
; CGSCC:       for.body.i4:
; CGSCC-NEXT:    [[IDXPROM_I5:%.*]] = sext i32 [[I_0_I2]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I6:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 91), i64 [[IDXPROM_I5]]
; CGSCC-NEXT:    store i32 [[I_0_I2]], ptr [[ARRAYIDX_I6]], align 4
; CGSCC-NEXT:    [[INC_I7]] = add nsw i32 [[I_0_I2]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I1]]
; CGSCC:       write10.exit8:
; CGSCC-NEXT:    [[TMP0:%.*]] = load i32, ptr @A, align 4
; CGSCC-NEXT:    [[TMP1:%.*]] = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], [[TMP1]]
; CGSCC-NEXT:    ret i32 [[ADD]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  %call = call ptr @get1Offset(ptr noundef @A)
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.body.i, %entry
  %i.0.i = phi i32 [ 0, %entry ], [ %inc.i, %for.body.i ]
  %cmp.i = icmp slt i32 %i.0.i, 10
  br i1 %cmp.i, label %for.body.i, label %write10.exit

for.body.i:                                       ; preds = %for.cond.i
  %idxprom.i = sext i32 %i.0.i to i64
  %arrayidx.i = getelementptr inbounds i32, ptr %call, i64 %idxprom.i
  store i32 %i.0.i, ptr %arrayidx.i, align 4
  %inc.i = add nsw i32 %i.0.i, 1
  br label %for.cond.i

write10.exit:                                     ; preds = %for.cond.i
  br label %for.cond.i1

for.cond.i1:                                      ; preds = %for.body.i4, %write10.exit
  %i.0.i2 = phi i32 [ 0, %write10.exit ], [ %inc.i7, %for.body.i4 ]
  %cmp.i3 = icmp slt i32 %i.0.i2, 10
  br i1 %cmp.i3, label %for.body.i4, label %write10.exit8

for.body.i4:                                      ; preds = %for.cond.i1
  %idxprom.i5 = sext i32 %i.0.i2 to i64
  %arrayidx.i6 = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 91), i64 %idxprom.i5
  store i32 %i.0.i2, ptr %arrayidx.i6, align 4
  %inc.i7 = add nsw i32 %i.0.i2, 1
  br label %for.cond.i1

write10.exit8:                                    ; preds = %for.cond.i1
  %0 = load i32, ptr @A, align 4
  %1 = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  %add = add nsw i32 %0, %1
  ret i32 %add
}

define i32 @range_no_overlap_negative_a() {
; TUNIT: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(write)
; TUNIT-LABEL: define {{[^@]+}}@range_no_overlap_negative_a
; TUNIT-SAME: () #[[ATTR0]] {
; TUNIT-NEXT:  entry:
; TUNIT-NEXT:    store i32 3, ptr @A, align 4
; TUNIT-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; TUNIT-NEXT:    br label [[FOR_COND_I:%.*]]
; TUNIT:       for.cond.i:
; TUNIT-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; TUNIT-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; TUNIT-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10NEGATIVE_EXIT:%.*]]
; TUNIT:       for.body.i:
; TUNIT-NEXT:    [[SUB_I:%.*]] = sub nsw i32 0, [[I_0_I]]
; TUNIT-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[SUB_I]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 10), i64 [[IDXPROM_I]]
; TUNIT-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I]]
; TUNIT:       write10negative.exit:
; TUNIT-NEXT:    br label [[FOR_COND_I1:%.*]]
; TUNIT:       for.cond.i1:
; TUNIT-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10NEGATIVE_EXIT]] ], [ [[INC_I8:%.*]], [[FOR_BODY_I4:%.*]] ]
; TUNIT-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; TUNIT-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10NEGATIVE_EXIT9:%.*]]
; TUNIT:       for.body.i4:
; TUNIT-NEXT:    [[SUB_I5:%.*]] = sub nsw i32 0, [[I_0_I2]]
; TUNIT-NEXT:    [[IDXPROM_I6:%.*]] = sext i32 [[SUB_I5]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I7:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 99), i64 [[IDXPROM_I6]]
; TUNIT-NEXT:    [[INC_I8]] = add nsw i32 [[I_0_I2]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I1]]
; TUNIT:       write10negative.exit9:
; TUNIT-NEXT:    ret i32 8
;
; CGSCC: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; CGSCC-LABEL: define {{[^@]+}}@range_no_overlap_negative_a
; CGSCC-SAME: () #[[ATTR0]] {
; CGSCC-NEXT:  entry:
; CGSCC-NEXT:    store i32 3, ptr @A, align 4
; CGSCC-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    br label [[FOR_COND_I:%.*]]
; CGSCC:       for.cond.i:
; CGSCC-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; CGSCC-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; CGSCC-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10NEGATIVE_EXIT:%.*]]
; CGSCC:       for.body.i:
; CGSCC-NEXT:    [[SUB_I:%.*]] = sub nsw i32 0, [[I_0_I]]
; CGSCC-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[SUB_I]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 10), i64 [[IDXPROM_I]]
; CGSCC-NEXT:    store i32 [[I_0_I]], ptr [[ARRAYIDX_I]], align 4
; CGSCC-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I]]
; CGSCC:       write10negative.exit:
; CGSCC-NEXT:    br label [[FOR_COND_I1:%.*]]
; CGSCC:       for.cond.i1:
; CGSCC-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10NEGATIVE_EXIT]] ], [ [[INC_I8:%.*]], [[FOR_BODY_I4:%.*]] ]
; CGSCC-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; CGSCC-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10NEGATIVE_EXIT9:%.*]]
; CGSCC:       for.body.i4:
; CGSCC-NEXT:    [[SUB_I5:%.*]] = sub nsw i32 0, [[I_0_I2]]
; CGSCC-NEXT:    [[IDXPROM_I6:%.*]] = sext i32 [[SUB_I5]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I7:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 99), i64 [[IDXPROM_I6]]
; CGSCC-NEXT:    store i32 [[I_0_I2]], ptr [[ARRAYIDX_I7]], align 4
; CGSCC-NEXT:    [[INC_I8]] = add nsw i32 [[I_0_I2]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I1]]
; CGSCC:       write10negative.exit9:
; CGSCC-NEXT:    [[TMP0:%.*]] = load i32, ptr @A, align 4
; CGSCC-NEXT:    [[TMP1:%.*]] = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], [[TMP1]]
; CGSCC-NEXT:    ret i32 [[ADD]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.body.i, %entry
  %i.0.i = phi i32 [ 0, %entry ], [ %inc.i, %for.body.i ]
  %cmp.i = icmp slt i32 %i.0.i, 10
  br i1 %cmp.i, label %for.body.i, label %write10negative.exit

for.body.i:                                       ; preds = %for.cond.i
  %sub.i = sub nsw i32 0, %i.0.i
  %idxprom.i = sext i32 %sub.i to i64
  %arrayidx.i = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 10), i64 %idxprom.i
  store i32 %i.0.i, ptr %arrayidx.i, align 4
  %inc.i = add nsw i32 %i.0.i, 1
  br label %for.cond.i

write10negative.exit:                             ; preds = %for.cond.i
  br label %for.cond.i1

for.cond.i1:                                      ; preds = %for.body.i4, %write10negative.exit
  %i.0.i2 = phi i32 [ 0, %write10negative.exit ], [ %inc.i8, %for.body.i4 ]
  %cmp.i3 = icmp slt i32 %i.0.i2, 10
  br i1 %cmp.i3, label %for.body.i4, label %write10negative.exit9

for.body.i4:                                      ; preds = %for.cond.i1
  %sub.i5 = sub nsw i32 0, %i.0.i2
  %idxprom.i6 = sext i32 %sub.i5 to i64
  %arrayidx.i7 = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 99), i64 %idxprom.i6
  store i32 %i.0.i2, ptr %arrayidx.i7, align 4
  %inc.i8 = add nsw i32 %i.0.i2, 1
  br label %for.cond.i1

write10negative.exit9:                            ; preds = %for.cond.i1
  %0 = load i32, ptr @A, align 4
  %1 = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  %add = add nsw i32 %0, %1
  ret i32 %add
}

define i32 @range_no_overlap_negative_b() {
; TUNIT: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(write)
; TUNIT-LABEL: define {{[^@]+}}@range_no_overlap_negative_b
; TUNIT-SAME: () #[[ATTR0]] {
; TUNIT-NEXT:  entry:
; TUNIT-NEXT:    store i32 3, ptr @A, align 4
; TUNIT-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; TUNIT-NEXT:    [[CALL:%.*]] = call ptr @get10Offset(ptr noalias nofree noundef nonnull readnone align 4 dereferenceable(404) "no-capture-maybe-returned" @A) #[[ATTR3]]
; TUNIT-NEXT:    br label [[FOR_COND_I:%.*]]
; TUNIT:       for.cond.i:
; TUNIT-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; TUNIT-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; TUNIT-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10NEGATIVE_EXIT:%.*]]
; TUNIT:       for.body.i:
; TUNIT-NEXT:    [[SUB_I:%.*]] = sub nsw i32 0, [[I_0_I]]
; TUNIT-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[SUB_I]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr [[CALL]], i64 [[IDXPROM_I]]
; TUNIT-NEXT:    store i32 [[I_0_I]], ptr [[ARRAYIDX_I]], align 4
; TUNIT-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I]]
; TUNIT:       write10negative.exit:
; TUNIT-NEXT:    br label [[FOR_COND_I1:%.*]]
; TUNIT:       for.cond.i1:
; TUNIT-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10NEGATIVE_EXIT]] ], [ [[INC_I8:%.*]], [[FOR_BODY_I4:%.*]] ]
; TUNIT-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; TUNIT-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10NEGATIVE_EXIT9:%.*]]
; TUNIT:       for.body.i4:
; TUNIT-NEXT:    [[SUB_I5:%.*]] = sub nsw i32 0, [[I_0_I2]]
; TUNIT-NEXT:    [[IDXPROM_I6:%.*]] = sext i32 [[SUB_I5]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I7:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 99), i64 [[IDXPROM_I6]]
; TUNIT-NEXT:    [[INC_I8]] = add nsw i32 [[I_0_I2]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I1]]
; TUNIT:       write10negative.exit9:
; TUNIT-NEXT:    ret i32 8
;
; CGSCC: Function Attrs: mustprogress nofree nosync nounwind willreturn
; CGSCC-LABEL: define {{[^@]+}}@range_no_overlap_negative_b
; CGSCC-SAME: () #[[ATTR1]] {
; CGSCC-NEXT:  entry:
; CGSCC-NEXT:    store i32 3, ptr @A, align 4
; CGSCC-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    [[CALL:%.*]] = call ptr @get10Offset(ptr noalias nofree noundef nonnull readnone align 4 dereferenceable(404) @A) #[[ATTR3]]
; CGSCC-NEXT:    br label [[FOR_COND_I:%.*]]
; CGSCC:       for.cond.i:
; CGSCC-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; CGSCC-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; CGSCC-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10NEGATIVE_EXIT:%.*]]
; CGSCC:       for.body.i:
; CGSCC-NEXT:    [[SUB_I:%.*]] = sub nsw i32 0, [[I_0_I]]
; CGSCC-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[SUB_I]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr [[CALL]], i64 [[IDXPROM_I]]
; CGSCC-NEXT:    store i32 [[I_0_I]], ptr [[ARRAYIDX_I]], align 4
; CGSCC-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I]]
; CGSCC:       write10negative.exit:
; CGSCC-NEXT:    br label [[FOR_COND_I1:%.*]]
; CGSCC:       for.cond.i1:
; CGSCC-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10NEGATIVE_EXIT]] ], [ [[INC_I8:%.*]], [[FOR_BODY_I4:%.*]] ]
; CGSCC-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; CGSCC-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10NEGATIVE_EXIT9:%.*]]
; CGSCC:       for.body.i4:
; CGSCC-NEXT:    [[SUB_I5:%.*]] = sub nsw i32 0, [[I_0_I2]]
; CGSCC-NEXT:    [[IDXPROM_I6:%.*]] = sext i32 [[SUB_I5]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I7:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 99), i64 [[IDXPROM_I6]]
; CGSCC-NEXT:    store i32 [[I_0_I2]], ptr [[ARRAYIDX_I7]], align 4
; CGSCC-NEXT:    [[INC_I8]] = add nsw i32 [[I_0_I2]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I1]]
; CGSCC:       write10negative.exit9:
; CGSCC-NEXT:    [[TMP0:%.*]] = load i32, ptr @A, align 4
; CGSCC-NEXT:    [[TMP1:%.*]] = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], [[TMP1]]
; CGSCC-NEXT:    ret i32 [[ADD]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  %call = call ptr @get10Offset(ptr noundef @A)
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.body.i, %entry
  %i.0.i = phi i32 [ 0, %entry ], [ %inc.i, %for.body.i ]
  %cmp.i = icmp slt i32 %i.0.i, 10
  br i1 %cmp.i, label %for.body.i, label %write10negative.exit

for.body.i:                                       ; preds = %for.cond.i
  %sub.i = sub nsw i32 0, %i.0.i
  %idxprom.i = sext i32 %sub.i to i64
  %arrayidx.i = getelementptr inbounds i32, ptr %call, i64 %idxprom.i
  store i32 %i.0.i, ptr %arrayidx.i, align 4
  %inc.i = add nsw i32 %i.0.i, 1
  br label %for.cond.i

write10negative.exit:                             ; preds = %for.cond.i
  br label %for.cond.i1

for.cond.i1:                                      ; preds = %for.body.i4, %write10negative.exit
  %i.0.i2 = phi i32 [ 0, %write10negative.exit ], [ %inc.i8, %for.body.i4 ]
  %cmp.i3 = icmp slt i32 %i.0.i2, 10
  br i1 %cmp.i3, label %for.body.i4, label %write10negative.exit9

for.body.i4:                                      ; preds = %for.cond.i1
  %sub.i5 = sub nsw i32 0, %i.0.i2
  %idxprom.i6 = sext i32 %sub.i5 to i64
  %arrayidx.i7 = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 99), i64 %idxprom.i6
  store i32 %i.0.i2, ptr %arrayidx.i7, align 4
  %inc.i8 = add nsw i32 %i.0.i2, 1
  br label %for.cond.i1

write10negative.exit9:                            ; preds = %for.cond.i1
  %0 = load i32, ptr @A, align 4
  %1 = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  %add = add nsw i32 %0, %1
  ret i32 %add
}

define ptr @get10Offset(ptr noundef %P) {
; TUNIT: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
; TUNIT-LABEL: define {{[^@]+}}@get10Offset
; TUNIT-SAME: (ptr nofree noundef readnone "no-capture-maybe-returned" [[P:%.*]]) #[[ATTR1]] {
; TUNIT-NEXT:  entry:
; TUNIT-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[P]], i64 10
; TUNIT-NEXT:    ret ptr [[ARRAYIDX]]
;
; CGSCC: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
; CGSCC-LABEL: define {{[^@]+}}@get10Offset
; CGSCC-SAME: (ptr nofree noundef readnone "no-capture-maybe-returned" [[P:%.*]]) #[[ATTR2]] {
; CGSCC-NEXT:  entry:
; CGSCC-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[P]], i64 10
; CGSCC-NEXT:    ret ptr [[ARRAYIDX]]
;
entry:
  %arrayidx = getelementptr inbounds i32, ptr %P, i64 10
  ret ptr %arrayidx
}

define i32 @range_overlap_1_negative_a() {
; TUNIT: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; TUNIT-LABEL: define {{[^@]+}}@range_overlap_1_negative_a
; TUNIT-SAME: () #[[ATTR2]] {
; TUNIT-NEXT:  entry:
; TUNIT-NEXT:    store i32 3, ptr @A, align 4
; TUNIT-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; TUNIT-NEXT:    br label [[FOR_COND_I:%.*]]
; TUNIT:       for.cond.i:
; TUNIT-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; TUNIT-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; TUNIT-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10NEGATIVE_EXIT:%.*]]
; TUNIT:       for.body.i:
; TUNIT-NEXT:    [[SUB_I:%.*]] = sub nsw i32 0, [[I_0_I]]
; TUNIT-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[SUB_I]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 9), i64 [[IDXPROM_I]]
; TUNIT-NEXT:    store i32 [[I_0_I]], ptr [[ARRAYIDX_I]], align 4
; TUNIT-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I]]
; TUNIT:       write10negative.exit:
; TUNIT-NEXT:    br label [[FOR_COND_I1:%.*]]
; TUNIT:       for.cond.i1:
; TUNIT-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10NEGATIVE_EXIT]] ], [ [[INC_I8:%.*]], [[FOR_BODY_I4:%.*]] ]
; TUNIT-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; TUNIT-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10NEGATIVE_EXIT9:%.*]]
; TUNIT:       for.body.i4:
; TUNIT-NEXT:    [[SUB_I5:%.*]] = sub nsw i32 0, [[I_0_I2]]
; TUNIT-NEXT:    [[IDXPROM_I6:%.*]] = sext i32 [[SUB_I5]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I7:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 99), i64 [[IDXPROM_I6]]
; TUNIT-NEXT:    [[INC_I8]] = add nsw i32 [[I_0_I2]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I1]]
; TUNIT:       write10negative.exit9:
; TUNIT-NEXT:    [[TMP0:%.*]] = load i32, ptr @A, align 4
; TUNIT-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], 5
; TUNIT-NEXT:    ret i32 [[ADD]]
;
; CGSCC: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; CGSCC-LABEL: define {{[^@]+}}@range_overlap_1_negative_a
; CGSCC-SAME: () #[[ATTR0]] {
; CGSCC-NEXT:  entry:
; CGSCC-NEXT:    store i32 3, ptr @A, align 4
; CGSCC-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    br label [[FOR_COND_I:%.*]]
; CGSCC:       for.cond.i:
; CGSCC-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; CGSCC-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; CGSCC-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10NEGATIVE_EXIT:%.*]]
; CGSCC:       for.body.i:
; CGSCC-NEXT:    [[SUB_I:%.*]] = sub nsw i32 0, [[I_0_I]]
; CGSCC-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[SUB_I]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 9), i64 [[IDXPROM_I]]
; CGSCC-NEXT:    store i32 [[I_0_I]], ptr [[ARRAYIDX_I]], align 4
; CGSCC-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I]]
; CGSCC:       write10negative.exit:
; CGSCC-NEXT:    br label [[FOR_COND_I1:%.*]]
; CGSCC:       for.cond.i1:
; CGSCC-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10NEGATIVE_EXIT]] ], [ [[INC_I8:%.*]], [[FOR_BODY_I4:%.*]] ]
; CGSCC-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; CGSCC-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10NEGATIVE_EXIT9:%.*]]
; CGSCC:       for.body.i4:
; CGSCC-NEXT:    [[SUB_I5:%.*]] = sub nsw i32 0, [[I_0_I2]]
; CGSCC-NEXT:    [[IDXPROM_I6:%.*]] = sext i32 [[SUB_I5]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I7:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 99), i64 [[IDXPROM_I6]]
; CGSCC-NEXT:    store i32 [[I_0_I2]], ptr [[ARRAYIDX_I7]], align 4
; CGSCC-NEXT:    [[INC_I8]] = add nsw i32 [[I_0_I2]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I1]]
; CGSCC:       write10negative.exit9:
; CGSCC-NEXT:    [[TMP0:%.*]] = load i32, ptr @A, align 4
; CGSCC-NEXT:    [[TMP1:%.*]] = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], [[TMP1]]
; CGSCC-NEXT:    ret i32 [[ADD]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.body.i, %entry
  %i.0.i = phi i32 [ 0, %entry ], [ %inc.i, %for.body.i ]
  %cmp.i = icmp slt i32 %i.0.i, 10
  br i1 %cmp.i, label %for.body.i, label %write10negative.exit

for.body.i:                                       ; preds = %for.cond.i
  %sub.i = sub nsw i32 0, %i.0.i
  %idxprom.i = sext i32 %sub.i to i64
  %arrayidx.i = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 9), i64 %idxprom.i
  store i32 %i.0.i, ptr %arrayidx.i, align 4
  %inc.i = add nsw i32 %i.0.i, 1
  br label %for.cond.i

write10negative.exit:                             ; preds = %for.cond.i
  br label %for.cond.i1

for.cond.i1:                                      ; preds = %for.body.i4, %write10negative.exit
  %i.0.i2 = phi i32 [ 0, %write10negative.exit ], [ %inc.i8, %for.body.i4 ]
  %cmp.i3 = icmp slt i32 %i.0.i2, 10
  br i1 %cmp.i3, label %for.body.i4, label %write10negative.exit9

for.body.i4:                                      ; preds = %for.cond.i1
  %sub.i5 = sub nsw i32 0, %i.0.i2
  %idxprom.i6 = sext i32 %sub.i5 to i64
  %arrayidx.i7 = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 99), i64 %idxprom.i6
  store i32 %i.0.i2, ptr %arrayidx.i7, align 4
  %inc.i8 = add nsw i32 %i.0.i2, 1
  br label %for.cond.i1

write10negative.exit9:                            ; preds = %for.cond.i1
  %0 = load i32, ptr @A, align 4
  %1 = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  %add = add nsw i32 %0, %1
  ret i32 %add
}

define i32 @range_overlap_1_negative_b() {
; TUNIT: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; TUNIT-LABEL: define {{[^@]+}}@range_overlap_1_negative_b
; TUNIT-SAME: () #[[ATTR2]] {
; TUNIT-NEXT:  entry:
; TUNIT-NEXT:    store i32 3, ptr @A, align 4
; TUNIT-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; TUNIT-NEXT:    [[CALL:%.*]] = call ptr @get9Offset(ptr noalias nofree noundef nonnull readnone align 4 dereferenceable(404) "no-capture-maybe-returned" @A) #[[ATTR3]]
; TUNIT-NEXT:    br label [[FOR_COND_I:%.*]]
; TUNIT:       for.cond.i:
; TUNIT-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; TUNIT-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; TUNIT-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10NEGATIVE_EXIT:%.*]]
; TUNIT:       for.body.i:
; TUNIT-NEXT:    [[SUB_I:%.*]] = sub nsw i32 0, [[I_0_I]]
; TUNIT-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[SUB_I]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr [[CALL]], i64 [[IDXPROM_I]]
; TUNIT-NEXT:    store i32 [[I_0_I]], ptr [[ARRAYIDX_I]], align 4
; TUNIT-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I]]
; TUNIT:       write10negative.exit:
; TUNIT-NEXT:    br label [[FOR_COND_I1:%.*]]
; TUNIT:       for.cond.i1:
; TUNIT-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10NEGATIVE_EXIT]] ], [ [[INC_I8:%.*]], [[FOR_BODY_I4:%.*]] ]
; TUNIT-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; TUNIT-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10NEGATIVE_EXIT9:%.*]]
; TUNIT:       for.body.i4:
; TUNIT-NEXT:    [[SUB_I5:%.*]] = sub nsw i32 0, [[I_0_I2]]
; TUNIT-NEXT:    [[IDXPROM_I6:%.*]] = sext i32 [[SUB_I5]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I7:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 99), i64 [[IDXPROM_I6]]
; TUNIT-NEXT:    [[INC_I8]] = add nsw i32 [[I_0_I2]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I1]]
; TUNIT:       write10negative.exit9:
; TUNIT-NEXT:    [[TMP0:%.*]] = load i32, ptr @A, align 4
; TUNIT-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], 5
; TUNIT-NEXT:    ret i32 [[ADD]]
;
; CGSCC: Function Attrs: mustprogress nofree nosync nounwind willreturn
; CGSCC-LABEL: define {{[^@]+}}@range_overlap_1_negative_b
; CGSCC-SAME: () #[[ATTR1]] {
; CGSCC-NEXT:  entry:
; CGSCC-NEXT:    store i32 3, ptr @A, align 4
; CGSCC-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    [[CALL:%.*]] = call ptr @get9Offset(ptr noalias nofree noundef nonnull readnone align 4 dereferenceable(404) @A) #[[ATTR3]]
; CGSCC-NEXT:    br label [[FOR_COND_I:%.*]]
; CGSCC:       for.cond.i:
; CGSCC-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; CGSCC-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; CGSCC-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10NEGATIVE_EXIT:%.*]]
; CGSCC:       for.body.i:
; CGSCC-NEXT:    [[SUB_I:%.*]] = sub nsw i32 0, [[I_0_I]]
; CGSCC-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[SUB_I]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr [[CALL]], i64 [[IDXPROM_I]]
; CGSCC-NEXT:    store i32 [[I_0_I]], ptr [[ARRAYIDX_I]], align 4
; CGSCC-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I]]
; CGSCC:       write10negative.exit:
; CGSCC-NEXT:    br label [[FOR_COND_I1:%.*]]
; CGSCC:       for.cond.i1:
; CGSCC-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10NEGATIVE_EXIT]] ], [ [[INC_I8:%.*]], [[FOR_BODY_I4:%.*]] ]
; CGSCC-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; CGSCC-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10NEGATIVE_EXIT9:%.*]]
; CGSCC:       for.body.i4:
; CGSCC-NEXT:    [[SUB_I5:%.*]] = sub nsw i32 0, [[I_0_I2]]
; CGSCC-NEXT:    [[IDXPROM_I6:%.*]] = sext i32 [[SUB_I5]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I7:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 99), i64 [[IDXPROM_I6]]
; CGSCC-NEXT:    store i32 [[I_0_I2]], ptr [[ARRAYIDX_I7]], align 4
; CGSCC-NEXT:    [[INC_I8]] = add nsw i32 [[I_0_I2]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I1]]
; CGSCC:       write10negative.exit9:
; CGSCC-NEXT:    [[TMP0:%.*]] = load i32, ptr @A, align 4
; CGSCC-NEXT:    [[TMP1:%.*]] = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], [[TMP1]]
; CGSCC-NEXT:    ret i32 [[ADD]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  %call = call ptr @get9Offset(ptr noundef @A)
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.body.i, %entry
  %i.0.i = phi i32 [ 0, %entry ], [ %inc.i, %for.body.i ]
  %cmp.i = icmp slt i32 %i.0.i, 10
  br i1 %cmp.i, label %for.body.i, label %write10negative.exit

for.body.i:                                       ; preds = %for.cond.i
  %sub.i = sub nsw i32 0, %i.0.i
  %idxprom.i = sext i32 %sub.i to i64
  %arrayidx.i = getelementptr inbounds i32, ptr %call, i64 %idxprom.i
  store i32 %i.0.i, ptr %arrayidx.i, align 4
  %inc.i = add nsw i32 %i.0.i, 1
  br label %for.cond.i

write10negative.exit:                             ; preds = %for.cond.i
  br label %for.cond.i1

for.cond.i1:                                      ; preds = %for.body.i4, %write10negative.exit
  %i.0.i2 = phi i32 [ 0, %write10negative.exit ], [ %inc.i8, %for.body.i4 ]
  %cmp.i3 = icmp slt i32 %i.0.i2, 10
  br i1 %cmp.i3, label %for.body.i4, label %write10negative.exit9

for.body.i4:                                      ; preds = %for.cond.i1
  %sub.i5 = sub nsw i32 0, %i.0.i2
  %idxprom.i6 = sext i32 %sub.i5 to i64
  %arrayidx.i7 = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 99), i64 %idxprom.i6
  store i32 %i.0.i2, ptr %arrayidx.i7, align 4
  %inc.i8 = add nsw i32 %i.0.i2, 1
  br label %for.cond.i1

write10negative.exit9:                            ; preds = %for.cond.i1
  %0 = load i32, ptr @A, align 4
  %1 = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  %add = add nsw i32 %0, %1
  ret i32 %add
}

define ptr @get9Offset(ptr noundef %P) {
; TUNIT: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
; TUNIT-LABEL: define {{[^@]+}}@get9Offset
; TUNIT-SAME: (ptr nofree noundef readnone "no-capture-maybe-returned" [[P:%.*]]) #[[ATTR1]] {
; TUNIT-NEXT:  entry:
; TUNIT-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[P]], i64 9
; TUNIT-NEXT:    ret ptr [[ARRAYIDX]]
;
; CGSCC: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(none)
; CGSCC-LABEL: define {{[^@]+}}@get9Offset
; CGSCC-SAME: (ptr nofree noundef readnone "no-capture-maybe-returned" [[P:%.*]]) #[[ATTR2]] {
; CGSCC-NEXT:  entry:
; CGSCC-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds i32, ptr [[P]], i64 9
; CGSCC-NEXT:    ret ptr [[ARRAYIDX]]
;
entry:
  %arrayidx = getelementptr inbounds i32, ptr %P, i64 9
  ret ptr %arrayidx
}

define i32 @range_overlap_2_negative_a() {
; TUNIT: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; TUNIT-LABEL: define {{[^@]+}}@range_overlap_2_negative_a
; TUNIT-SAME: () #[[ATTR2]] {
; TUNIT-NEXT:  entry:
; TUNIT-NEXT:    store i32 3, ptr @A, align 4
; TUNIT-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; TUNIT-NEXT:    br label [[FOR_COND_I:%.*]]
; TUNIT:       for.cond.i:
; TUNIT-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; TUNIT-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; TUNIT-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10NEGATIVE_EXIT:%.*]]
; TUNIT:       for.body.i:
; TUNIT-NEXT:    [[SUB_I:%.*]] = sub nsw i32 0, [[I_0_I]]
; TUNIT-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[SUB_I]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 10), i64 [[IDXPROM_I]]
; TUNIT-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I]]
; TUNIT:       write10negative.exit:
; TUNIT-NEXT:    br label [[FOR_COND_I1:%.*]]
; TUNIT:       for.cond.i1:
; TUNIT-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10NEGATIVE_EXIT]] ], [ [[INC_I8:%.*]], [[FOR_BODY_I4:%.*]] ]
; TUNIT-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; TUNIT-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10NEGATIVE_EXIT9:%.*]]
; TUNIT:       for.body.i4:
; TUNIT-NEXT:    [[SUB_I5:%.*]] = sub nsw i32 0, [[I_0_I2]]
; TUNIT-NEXT:    [[IDXPROM_I6:%.*]] = sext i32 [[SUB_I5]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I7:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), i64 [[IDXPROM_I6]]
; TUNIT-NEXT:    store i32 [[I_0_I2]], ptr [[ARRAYIDX_I7]], align 4
; TUNIT-NEXT:    [[INC_I8]] = add nsw i32 [[I_0_I2]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I1]]
; TUNIT:       write10negative.exit9:
; TUNIT-NEXT:    [[TMP0:%.*]] = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; TUNIT-NEXT:    [[ADD:%.*]] = add nsw i32 3, [[TMP0]]
; TUNIT-NEXT:    ret i32 [[ADD]]
;
; CGSCC: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; CGSCC-LABEL: define {{[^@]+}}@range_overlap_2_negative_a
; CGSCC-SAME: () #[[ATTR0]] {
; CGSCC-NEXT:  entry:
; CGSCC-NEXT:    store i32 3, ptr @A, align 4
; CGSCC-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    br label [[FOR_COND_I:%.*]]
; CGSCC:       for.cond.i:
; CGSCC-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; CGSCC-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; CGSCC-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10NEGATIVE_EXIT:%.*]]
; CGSCC:       for.body.i:
; CGSCC-NEXT:    [[SUB_I:%.*]] = sub nsw i32 0, [[I_0_I]]
; CGSCC-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[SUB_I]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 10), i64 [[IDXPROM_I]]
; CGSCC-NEXT:    store i32 [[I_0_I]], ptr [[ARRAYIDX_I]], align 4
; CGSCC-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I]]
; CGSCC:       write10negative.exit:
; CGSCC-NEXT:    br label [[FOR_COND_I1:%.*]]
; CGSCC:       for.cond.i1:
; CGSCC-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10NEGATIVE_EXIT]] ], [ [[INC_I8:%.*]], [[FOR_BODY_I4:%.*]] ]
; CGSCC-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; CGSCC-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10NEGATIVE_EXIT9:%.*]]
; CGSCC:       for.body.i4:
; CGSCC-NEXT:    [[SUB_I5:%.*]] = sub nsw i32 0, [[I_0_I2]]
; CGSCC-NEXT:    [[IDXPROM_I6:%.*]] = sext i32 [[SUB_I5]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I7:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), i64 [[IDXPROM_I6]]
; CGSCC-NEXT:    store i32 [[I_0_I2]], ptr [[ARRAYIDX_I7]], align 4
; CGSCC-NEXT:    [[INC_I8]] = add nsw i32 [[I_0_I2]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I1]]
; CGSCC:       write10negative.exit9:
; CGSCC-NEXT:    [[TMP0:%.*]] = load i32, ptr @A, align 4
; CGSCC-NEXT:    [[TMP1:%.*]] = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], [[TMP1]]
; CGSCC-NEXT:    ret i32 [[ADD]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.body.i, %entry
  %i.0.i = phi i32 [ 0, %entry ], [ %inc.i, %for.body.i ]
  %cmp.i = icmp slt i32 %i.0.i, 10
  br i1 %cmp.i, label %for.body.i, label %write10negative.exit

for.body.i:                                       ; preds = %for.cond.i
  %sub.i = sub nsw i32 0, %i.0.i
  %idxprom.i = sext i32 %sub.i to i64
  %arrayidx.i = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 10), i64 %idxprom.i
  store i32 %i.0.i, ptr %arrayidx.i, align 4
  %inc.i = add nsw i32 %i.0.i, 1
  br label %for.cond.i

write10negative.exit:                             ; preds = %for.cond.i
  br label %for.cond.i1

for.cond.i1:                                      ; preds = %for.body.i4, %write10negative.exit
  %i.0.i2 = phi i32 [ 0, %write10negative.exit ], [ %inc.i8, %for.body.i4 ]
  %cmp.i3 = icmp slt i32 %i.0.i2, 10
  br i1 %cmp.i3, label %for.body.i4, label %write10negative.exit9

for.body.i4:                                      ; preds = %for.cond.i1
  %sub.i5 = sub nsw i32 0, %i.0.i2
  %idxprom.i6 = sext i32 %sub.i5 to i64
  %arrayidx.i7 = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), i64 %idxprom.i6
  store i32 %i.0.i2, ptr %arrayidx.i7, align 4
  %inc.i8 = add nsw i32 %i.0.i2, 1
  br label %for.cond.i1

write10negative.exit9:                            ; preds = %for.cond.i1
  %0 = load i32, ptr @A, align 4
  %1 = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  %add = add nsw i32 %0, %1
  ret i32 %add
}

define i32 @range_overlap_2_negative_b() {
; TUNIT: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; TUNIT-LABEL: define {{[^@]+}}@range_overlap_2_negative_b
; TUNIT-SAME: () #[[ATTR2]] {
; TUNIT-NEXT:  entry:
; TUNIT-NEXT:    store i32 3, ptr @A, align 4
; TUNIT-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; TUNIT-NEXT:    [[CALL:%.*]] = call ptr @get10Offset(ptr noalias nofree noundef nonnull readnone align 4 dereferenceable(404) "no-capture-maybe-returned" @A) #[[ATTR3]]
; TUNIT-NEXT:    br label [[FOR_COND_I:%.*]]
; TUNIT:       for.cond.i:
; TUNIT-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; TUNIT-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; TUNIT-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10NEGATIVE_EXIT:%.*]]
; TUNIT:       for.body.i:
; TUNIT-NEXT:    [[SUB_I:%.*]] = sub nsw i32 0, [[I_0_I]]
; TUNIT-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[SUB_I]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr [[CALL]], i64 [[IDXPROM_I]]
; TUNIT-NEXT:    store i32 [[I_0_I]], ptr [[ARRAYIDX_I]], align 4
; TUNIT-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I]]
; TUNIT:       write10negative.exit:
; TUNIT-NEXT:    br label [[FOR_COND_I1:%.*]]
; TUNIT:       for.cond.i1:
; TUNIT-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10NEGATIVE_EXIT]] ], [ [[INC_I8:%.*]], [[FOR_BODY_I4:%.*]] ]
; TUNIT-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; TUNIT-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10NEGATIVE_EXIT9:%.*]]
; TUNIT:       for.body.i4:
; TUNIT-NEXT:    [[SUB_I5:%.*]] = sub nsw i32 0, [[I_0_I2]]
; TUNIT-NEXT:    [[IDXPROM_I6:%.*]] = sext i32 [[SUB_I5]] to i64
; TUNIT-NEXT:    [[ARRAYIDX_I7:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), i64 [[IDXPROM_I6]]
; TUNIT-NEXT:    store i32 [[I_0_I2]], ptr [[ARRAYIDX_I7]], align 4
; TUNIT-NEXT:    [[INC_I8]] = add nsw i32 [[I_0_I2]], 1
; TUNIT-NEXT:    br label [[FOR_COND_I1]]
; TUNIT:       write10negative.exit9:
; TUNIT-NEXT:    [[TMP0:%.*]] = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; TUNIT-NEXT:    [[ADD:%.*]] = add nsw i32 3, [[TMP0]]
; TUNIT-NEXT:    ret i32 [[ADD]]
;
; CGSCC: Function Attrs: mustprogress nofree nosync nounwind willreturn
; CGSCC-LABEL: define {{[^@]+}}@range_overlap_2_negative_b
; CGSCC-SAME: () #[[ATTR1]] {
; CGSCC-NEXT:  entry:
; CGSCC-NEXT:    store i32 3, ptr @A, align 4
; CGSCC-NEXT:    store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    [[CALL:%.*]] = call ptr @get10Offset(ptr noalias nofree noundef nonnull readnone align 4 dereferenceable(404) @A) #[[ATTR3]]
; CGSCC-NEXT:    br label [[FOR_COND_I:%.*]]
; CGSCC:       for.cond.i:
; CGSCC-NEXT:    [[I_0_I:%.*]] = phi i32 [ 0, [[ENTRY:%.*]] ], [ [[INC_I:%.*]], [[FOR_BODY_I:%.*]] ]
; CGSCC-NEXT:    [[CMP_I:%.*]] = icmp slt i32 [[I_0_I]], 10
; CGSCC-NEXT:    br i1 [[CMP_I]], label [[FOR_BODY_I]], label [[WRITE10NEGATIVE_EXIT:%.*]]
; CGSCC:       for.body.i:
; CGSCC-NEXT:    [[SUB_I:%.*]] = sub nsw i32 0, [[I_0_I]]
; CGSCC-NEXT:    [[IDXPROM_I:%.*]] = sext i32 [[SUB_I]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I:%.*]] = getelementptr inbounds i32, ptr [[CALL]], i64 [[IDXPROM_I]]
; CGSCC-NEXT:    store i32 [[I_0_I]], ptr [[ARRAYIDX_I]], align 4
; CGSCC-NEXT:    [[INC_I]] = add nsw i32 [[I_0_I]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I]]
; CGSCC:       write10negative.exit:
; CGSCC-NEXT:    br label [[FOR_COND_I1:%.*]]
; CGSCC:       for.cond.i1:
; CGSCC-NEXT:    [[I_0_I2:%.*]] = phi i32 [ 0, [[WRITE10NEGATIVE_EXIT]] ], [ [[INC_I8:%.*]], [[FOR_BODY_I4:%.*]] ]
; CGSCC-NEXT:    [[CMP_I3:%.*]] = icmp slt i32 [[I_0_I2]], 10
; CGSCC-NEXT:    br i1 [[CMP_I3]], label [[FOR_BODY_I4]], label [[WRITE10NEGATIVE_EXIT9:%.*]]
; CGSCC:       for.body.i4:
; CGSCC-NEXT:    [[SUB_I5:%.*]] = sub nsw i32 0, [[I_0_I2]]
; CGSCC-NEXT:    [[IDXPROM_I6:%.*]] = sext i32 [[SUB_I5]] to i64
; CGSCC-NEXT:    [[ARRAYIDX_I7:%.*]] = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), i64 [[IDXPROM_I6]]
; CGSCC-NEXT:    store i32 [[I_0_I2]], ptr [[ARRAYIDX_I7]], align 4
; CGSCC-NEXT:    [[INC_I8]] = add nsw i32 [[I_0_I2]], 1
; CGSCC-NEXT:    br label [[FOR_COND_I1]]
; CGSCC:       write10negative.exit9:
; CGSCC-NEXT:    [[TMP0:%.*]] = load i32, ptr @A, align 4
; CGSCC-NEXT:    [[TMP1:%.*]] = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
; CGSCC-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], [[TMP1]]
; CGSCC-NEXT:    ret i32 [[ADD]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  %call = call ptr @get10Offset(ptr noundef @A)
  br label %for.cond.i

for.cond.i:                                       ; preds = %for.body.i, %entry
  %i.0.i = phi i32 [ 0, %entry ], [ %inc.i, %for.body.i ]
  %cmp.i = icmp slt i32 %i.0.i, 10
  br i1 %cmp.i, label %for.body.i, label %write10negative.exit

for.body.i:                                       ; preds = %for.cond.i
  %sub.i = sub nsw i32 0, %i.0.i
  %idxprom.i = sext i32 %sub.i to i64
  %arrayidx.i = getelementptr inbounds i32, ptr %call, i64 %idxprom.i
  store i32 %i.0.i, ptr %arrayidx.i, align 4
  %inc.i = add nsw i32 %i.0.i, 1
  br label %for.cond.i

write10negative.exit:                             ; preds = %for.cond.i
  br label %for.cond.i1

for.cond.i1:                                      ; preds = %for.body.i4, %write10negative.exit
  %i.0.i2 = phi i32 [ 0, %write10negative.exit ], [ %inc.i8, %for.body.i4 ]
  %cmp.i3 = icmp slt i32 %i.0.i2, 10
  br i1 %cmp.i3, label %for.body.i4, label %write10negative.exit9

for.body.i4:                                      ; preds = %for.cond.i1
  %sub.i5 = sub nsw i32 0, %i.0.i2
  %idxprom.i6 = sext i32 %sub.i5 to i64
  %arrayidx.i7 = getelementptr inbounds i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), i64 %idxprom.i6
  store i32 %i.0.i2, ptr %arrayidx.i7, align 4
  %inc.i8 = add nsw i32 %i.0.i2, 1
  br label %for.cond.i1

write10negative.exit9:                            ; preds = %for.cond.i1
  %0 = load i32, ptr @A, align 4
  %1 = load i32, ptr getelementptr inbounds ([101 x i32], ptr @A, i64 0, i64 100), align 4
  %add = add nsw i32 %0, %1
  ret i32 %add
}
;.
; TUNIT: attributes #[[ATTR0]] = { mustprogress nofree norecurse nosync nounwind willreturn memory(write) }
; TUNIT: attributes #[[ATTR1]] = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) }
; TUNIT: attributes #[[ATTR2]] = { mustprogress nofree norecurse nosync nounwind willreturn }
; TUNIT: attributes #[[ATTR3]] = { nofree nosync nounwind willreturn memory(none) }
;.
; CGSCC: attributes #[[ATTR0]] = { mustprogress nofree norecurse nosync nounwind willreturn }
; CGSCC: attributes #[[ATTR1]] = { mustprogress nofree nosync nounwind willreturn }
; CGSCC: attributes #[[ATTR2]] = { mustprogress nofree norecurse nosync nounwind willreturn memory(none) }
; CGSCC: attributes #[[ATTR3]] = { nofree nosync willreturn }
;.
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CHECK: {{.*}}
