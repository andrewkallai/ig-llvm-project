; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --function-signature --check-attributes --check-globals
; RUN: opt -aa-pipeline=basic-aa -passes=attributor -attributor-manifest-internal  -attributor-annotate-decl-cs  -S < %s | FileCheck %s --check-prefixes=CHECK,TUNIT
; RUN: opt -aa-pipeline=basic-aa -passes=attributor-cgscc -attributor-manifest-internal  -attributor-annotate-decl-cs -S < %s | FileCheck %s --check-prefixes=CHECK,CGSCC

@A = internal unnamed_addr global [101 x i32] zeroinitializer, align 4

; Function Attrs: nofree norecurse nosync nounwind ssp memory(readwrite, argmem: none, inaccessiblemem: none) uwtable(sync)
;.
; CHECK: @A = internal unnamed_addr global [101 x i32] zeroinitializer, align 4
;.
define range(i32 -2147483645, -2147483648) i32 @range_no_overlap() local_unnamed_addr #0 {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(write)
; CHECK-LABEL: define {{[^@]+}}@range_no_overlap
; CHECK-SAME: () local_unnamed_addr #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store i32 3, ptr @A, align 4
; CHECK-NEXT:    store i32 5, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret i32 8
; CHECK:       for.body:
; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 1, [[ENTRY:%.*]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw [101 x i32], ptr @A, i64 0, i64 [[INDVARS_IV]]
; CHECK-NEXT:    [[TMP0:%.*]] = trunc nuw nsw i64 [[INDVARS_IV]] to i32
; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 100
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body
  %0 = load i32, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
  %a = load i32, ptr @A, align 4
  %add = add nsw i32 %0, %a
  ret i32 %add

for.body:                                         ; preds = %entry, %for.body
  %indvars.iv = phi i64 [ 1, %entry ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds nuw [101 x i32], ptr @A, i64 0, i64 %indvars.iv
  %1 = trunc nuw nsw i64 %indvars.iv to i32
  store i32 %1, ptr %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 100
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

; Function Attrs: nofree norecurse nosync nounwind ssp memory(readwrite, argmem: none, inaccessiblemem: none) uwtable(sync)
define i32 @range_no_overlap_char() local_unnamed_addr #0 {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(write)
; CHECK-LABEL: define {{[^@]+}}@range_no_overlap_char
; CHECK-SAME: () local_unnamed_addr #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store i32 3, ptr @A, align 4
; CHECK-NEXT:    store i32 5, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret i32 8
; CHECK:       for.body:
; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 4, [[ENTRY:%.*]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CONV2:%.*]] = trunc i64 [[INDVARS_IV]] to i8
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw i8, ptr @A, i64 [[INDVARS_IV]]
; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 400
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body
  %0 = load i32, ptr @A, align 4
  %1 = load i32, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
  %add = add nsw i32 %1, %0
  ret i32 %add

for.body:                                         ; preds = %entry, %for.body
  %indvars.iv = phi i64 [ 4, %entry ], [ %indvars.iv.next, %for.body ]
  %conv2 = trunc i64 %indvars.iv to i8
  %arrayidx = getelementptr inbounds nuw i8, ptr @A, i64 %indvars.iv
  store i8 %conv2, ptr %arrayidx, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 400
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

; Function Attrs: nofree norecurse nosync nounwind ssp memory(readwrite, argmem: none, inaccessiblemem: none) uwtable(sync)
define i32 @range_overlap_1() local_unnamed_addr #0 {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; CHECK-LABEL: define {{[^@]+}}@range_overlap_1
; CHECK-SAME: () local_unnamed_addr #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store i32 3, ptr @A, align 4
; CHECK-NEXT:    store i32 5, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr @A, align 4
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 5, [[TMP0]]
; CHECK-NEXT:    ret i32 [[ADD]]
; CHECK:       for.body:
; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw [101 x i32], ptr @A, i64 0, i64 [[INDVARS_IV]]
; CHECK-NEXT:    [[TMP1:%.*]] = trunc nuw nsw i64 [[INDVARS_IV]] to i32
; CHECK-NEXT:    store i32 [[TMP1]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 100
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body
  %0 = load i32, ptr @A, align 4
  %1 = load i32, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
  %add = add nsw i32 %1, %0
  ret i32 %add

for.body:                                         ; preds = %entry, %for.body
  %indvars.iv = phi i64 [ 0, %entry ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds nuw [101 x i32], ptr @A, i64 0, i64 %indvars.iv
  %2 = trunc nuw nsw i64 %indvars.iv to i32
  store i32 %2, ptr %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 100
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

; Function Attrs: nofree norecurse nosync nounwind ssp memory(readwrite, argmem: none, inaccessiblemem: none) uwtable(sync)
define range(i32 -2147483645, -2147483648) i32 @range_overlap_2() local_unnamed_addr #0 {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; CHECK-LABEL: define {{[^@]+}}@range_overlap_2
; CHECK-SAME: () local_unnamed_addr #[[ATTR1]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store i32 3, ptr @A, align 4
; CHECK-NEXT:    store i32 5, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], 3
; CHECK-NEXT:    ret i32 [[ADD]]
; CHECK:       for.body:
; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 1, [[ENTRY:%.*]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw [101 x i32], ptr @A, i64 0, i64 [[INDVARS_IV]]
; CHECK-NEXT:    [[TMP1:%.*]] = trunc nuw nsw i64 [[INDVARS_IV]] to i32
; CHECK-NEXT:    store i32 [[TMP1]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 101
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body
  %0 = load i32, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
  %add = add nsw i32 %0, 3
  ret i32 %add

for.body:                                         ; preds = %entry, %for.body
  %indvars.iv = phi i64 [ 1, %entry ], [ %indvars.iv.next, %for.body ]
  %arrayidx = getelementptr inbounds nuw [101 x i32], ptr @A, i64 0, i64 %indvars.iv
  %1 = trunc nuw nsw i64 %indvars.iv to i32
  store i32 %1, ptr %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 101
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

; Function Attrs: nofree norecurse nosync nounwind ssp memory(readwrite, argmem: none, inaccessiblemem: none) uwtable(sync)
define i32 @range_overlap_char_1() local_unnamed_addr #0 {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; CHECK-LABEL: define {{[^@]+}}@range_overlap_char_1
; CHECK-SAME: () local_unnamed_addr #[[ATTR1]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store i32 3, ptr @A, align 4
; CHECK-NEXT:    store i32 5, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr @A, align 4
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 5, [[TMP0]]
; CHECK-NEXT:    ret i32 [[ADD]]
; CHECK:       for.body:
; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 3, [[ENTRY:%.*]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CONV2:%.*]] = trunc i64 [[INDVARS_IV]] to i8
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw i8, ptr @A, i64 [[INDVARS_IV]]
; CHECK-NEXT:    store i8 [[CONV2]], ptr [[ARRAYIDX]], align 1
; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 400
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body
  %0 = load i32, ptr @A, align 4
  %1 = load i32, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
  %add = add nsw i32 %1, %0
  ret i32 %add

for.body:                                         ; preds = %entry, %for.body
  %indvars.iv = phi i64 [ 3, %entry ], [ %indvars.iv.next, %for.body ]
  %conv2 = trunc i64 %indvars.iv to i8
  %arrayidx = getelementptr inbounds nuw i8, ptr @A, i64 %indvars.iv
  store i8 %conv2, ptr %arrayidx, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 400
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

; Function Attrs: nofree norecurse nosync nounwind ssp memory(readwrite, argmem: none, inaccessiblemem: none) uwtable(sync)
define i32 @range_overlap_char_2() local_unnamed_addr #0 {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; CHECK-LABEL: define {{[^@]+}}@range_overlap_char_2
; CHECK-SAME: () local_unnamed_addr #[[ATTR1]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store i32 3, ptr @A, align 4
; CHECK-NEXT:    store i32 5, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
; CHECK-NEXT:    br label [[FOR_BODY:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
; CHECK-NEXT:    [[ADD:%.*]] = add nsw i32 [[TMP0]], 3
; CHECK-NEXT:    ret i32 [[ADD]]
; CHECK:       for.body:
; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 4, [[ENTRY:%.*]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY]] ]
; CHECK-NEXT:    [[CONV2:%.*]] = trunc i64 [[INDVARS_IV]] to i8
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw i8, ptr @A, i64 [[INDVARS_IV]]
; CHECK-NEXT:    store i8 [[CONV2]], ptr [[ARRAYIDX]], align 1
; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 401
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_BODY]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
  br label %for.body

for.cond.cleanup:                                 ; preds = %for.body
  %0 = load i32, ptr @A, align 4
  %1 = load i32, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
  %add = add nsw i32 %1, %0
  ret i32 %add

for.body:                                         ; preds = %entry, %for.body
  %indvars.iv = phi i64 [ 4, %entry ], [ %indvars.iv.next, %for.body ]
  %conv2 = trunc i64 %indvars.iv to i8
  %arrayidx = getelementptr inbounds nuw i8, ptr @A, i64 %indvars.iv
  store i8 %conv2, ptr %arrayidx, align 1
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 401
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body
}

; Function Attrs: nofree norecurse nosync nounwind ssp memory(readwrite, argmem: none, inaccessiblemem: none) uwtable(sync)
define range(i32 -2147483645, -2147483648) i32 @range_no_overlap_2d() local_unnamed_addr #0 {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn memory(write)
; CHECK-LABEL: define {{[^@]+}}@range_no_overlap_2d
; CHECK-SAME: () local_unnamed_addr #[[ATTR0]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store i32 3, ptr @A, align 4
; CHECK-NEXT:    store i32 5, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
; CHECK-NEXT:    br label [[FOR_COND1_PREHEADER:%.*]]
; CHECK:       for.cond1.preheader:
; CHECK-NEXT:    [[INDVARS_IV21:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[INDVARS_IV_NEXT22:%.*]], [[FOR_COND_CLEANUP3:%.*]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = mul nuw nsw i64 [[INDVARS_IV21]], 10
; CHECK-NEXT:    br label [[FOR_BODY4:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    ret i32 8
; CHECK:       for.cond.cleanup3:
; CHECK-NEXT:    [[INDVARS_IV_NEXT22]] = add nuw nsw i64 [[INDVARS_IV21]], 1
; CHECK-NEXT:    [[EXITCOND25_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT22]], 10
; CHECK-NEXT:    br i1 [[EXITCOND25_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_COND1_PREHEADER]]
; CHECK:       for.body4:
; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 1, [[FOR_COND1_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY4]] ]
; CHECK-NEXT:    [[TMP1:%.*]] = mul nuw nsw i64 [[INDVARS_IV]], [[INDVARS_IV21]]
; CHECK-NEXT:    [[TMP2:%.*]] = add nuw nsw i64 [[INDVARS_IV]], [[TMP0]]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw [101 x i32], ptr @A, i64 0, i64 [[TMP2]]
; CHECK-NEXT:    [[TMP3:%.*]] = trunc nuw nsw i64 [[TMP1]] to i32
; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 10
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP3]], label [[FOR_BODY4]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
  br label %for.cond1.preheader

for.cond1.preheader:                              ; preds = %entry, %for.cond.cleanup3
  %indvars.iv21 = phi i64 [ 0, %entry ], [ %indvars.iv.next22, %for.cond.cleanup3 ]
  %0 = mul nuw nsw i64 %indvars.iv21, 10
  br label %for.body4

for.cond.cleanup:                                 ; preds = %for.cond.cleanup3
  %1 = load i32, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
  %add9 = add nsw i32 %1, 3
  ret i32 %add9

for.cond.cleanup3:                                ; preds = %for.body4
  %indvars.iv.next22 = add nuw nsw i64 %indvars.iv21, 1
  %exitcond25.not = icmp eq i64 %indvars.iv.next22, 10
  br i1 %exitcond25.not, label %for.cond.cleanup, label %for.cond1.preheader

for.body4:                                        ; preds = %for.cond1.preheader, %for.body4
  %indvars.iv = phi i64 [ 1, %for.cond1.preheader ], [ %indvars.iv.next, %for.body4 ]
  %2 = mul nuw nsw i64 %indvars.iv, %indvars.iv21
  %3 = add nuw nsw i64 %indvars.iv, %0
  %arrayidx = getelementptr inbounds nuw [101 x i32], ptr @A, i64 0, i64 %3
  %4 = trunc nuw nsw i64 %2 to i32
  store i32 %4, ptr %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 10
  br i1 %exitcond.not, label %for.cond.cleanup3, label %for.body4
}

; Function Attrs: nofree norecurse nosync nounwind ssp memory(readwrite, argmem: none, inaccessiblemem: none) uwtable(sync)
define i32 @range_overlap_2d_1() local_unnamed_addr #0 {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; CHECK-LABEL: define {{[^@]+}}@range_overlap_2d_1
; CHECK-SAME: () local_unnamed_addr #[[ATTR1]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store i32 3, ptr @A, align 4
; CHECK-NEXT:    store i32 5, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
; CHECK-NEXT:    br label [[FOR_COND1_PREHEADER:%.*]]
; CHECK:       for.cond1.preheader:
; CHECK-NEXT:    [[INDVARS_IV21:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[INDVARS_IV_NEXT22:%.*]], [[FOR_COND_CLEANUP3:%.*]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = mul nuw nsw i64 [[INDVARS_IV21]], 10
; CHECK-NEXT:    br label [[FOR_BODY4:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr @A, align 4
; CHECK-NEXT:    [[ADD9:%.*]] = add nsw i32 5, [[TMP1]]
; CHECK-NEXT:    ret i32 [[ADD9]]
; CHECK:       for.cond.cleanup3:
; CHECK-NEXT:    [[INDVARS_IV_NEXT22]] = add nuw nsw i64 [[INDVARS_IV21]], 1
; CHECK-NEXT:    [[EXITCOND25_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT22]], 10
; CHECK-NEXT:    br i1 [[EXITCOND25_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_COND1_PREHEADER]]
; CHECK:       for.body4:
; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_COND1_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY4]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = mul nuw nsw i64 [[INDVARS_IV]], [[INDVARS_IV21]]
; CHECK-NEXT:    [[TMP3:%.*]] = add nuw nsw i64 [[INDVARS_IV]], [[TMP0]]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw [101 x i32], ptr @A, i64 0, i64 [[TMP3]]
; CHECK-NEXT:    [[TMP4:%.*]] = trunc nuw nsw i64 [[TMP2]] to i32
; CHECK-NEXT:    store i32 [[TMP4]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 10
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP3]], label [[FOR_BODY4]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
  br label %for.cond1.preheader

for.cond1.preheader:                              ; preds = %entry, %for.cond.cleanup3
  %indvars.iv21 = phi i64 [ 0, %entry ], [ %indvars.iv.next22, %for.cond.cleanup3 ]
  %0 = mul nuw nsw i64 %indvars.iv21, 10
  br label %for.body4

for.cond.cleanup:                                 ; preds = %for.cond.cleanup3
  %1 = load i32, ptr @A, align 4
  %2 = load i32, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
  %add9 = add nsw i32 %2, %1
  ret i32 %add9

for.cond.cleanup3:                                ; preds = %for.body4
  %indvars.iv.next22 = add nuw nsw i64 %indvars.iv21, 1
  %exitcond25.not = icmp eq i64 %indvars.iv.next22, 10
  br i1 %exitcond25.not, label %for.cond.cleanup, label %for.cond1.preheader

for.body4:                                        ; preds = %for.cond1.preheader, %for.body4
  %indvars.iv = phi i64 [ 0, %for.cond1.preheader ], [ %indvars.iv.next, %for.body4 ]
  %3 = mul nuw nsw i64 %indvars.iv, %indvars.iv21
  %4 = add nuw nsw i64 %indvars.iv, %0
  %arrayidx = getelementptr inbounds nuw [101 x i32], ptr @A, i64 0, i64 %4
  %5 = trunc nuw nsw i64 %3 to i32
  store i32 %5, ptr %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 10
  br i1 %exitcond.not, label %for.cond.cleanup3, label %for.body4
}

; Function Attrs: nofree norecurse nosync nounwind ssp memory(readwrite, argmem: none, inaccessiblemem: none) uwtable(sync)
define range(i32 -2147483645, -2147483648) i32 @range_overlap_2d_2a() local_unnamed_addr #0 {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; CHECK-LABEL: define {{[^@]+}}@range_overlap_2d_2a
; CHECK-SAME: () local_unnamed_addr #[[ATTR1]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store i32 3, ptr @A, align 4
; CHECK-NEXT:    store i32 5, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
; CHECK-NEXT:    br label [[FOR_COND1_PREHEADER:%.*]]
; CHECK:       for.cond1.preheader:
; CHECK-NEXT:    [[INDVARS_IV21:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[INDVARS_IV_NEXT22:%.*]], [[FOR_COND_CLEANUP3:%.*]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = mul nuw nsw i64 [[INDVARS_IV21]], 10
; CHECK-NEXT:    br label [[FOR_BODY4:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    [[TMP1:%.*]] = load i32, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
; CHECK-NEXT:    [[ADD9:%.*]] = add nsw i32 [[TMP1]], 3
; CHECK-NEXT:    ret i32 [[ADD9]]
; CHECK:       for.cond.cleanup3:
; CHECK-NEXT:    [[INDVARS_IV_NEXT22]] = add nuw nsw i64 [[INDVARS_IV21]], 1
; CHECK-NEXT:    [[EXITCOND25_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT22]], 10
; CHECK-NEXT:    br i1 [[EXITCOND25_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_COND1_PREHEADER]]
; CHECK:       for.body4:
; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 1, [[FOR_COND1_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY4]] ]
; CHECK-NEXT:    [[TMP2:%.*]] = mul nuw nsw i64 [[INDVARS_IV]], [[INDVARS_IV21]]
; CHECK-NEXT:    [[TMP3:%.*]] = add nuw nsw i64 [[INDVARS_IV]], [[TMP0]]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw [101 x i32], ptr @A, i64 0, i64 [[TMP3]]
; CHECK-NEXT:    [[TMP4:%.*]] = trunc nuw nsw i64 [[TMP2]] to i32
; CHECK-NEXT:    store i32 [[TMP4]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 11
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP3]], label [[FOR_BODY4]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
  br label %for.cond1.preheader

for.cond1.preheader:                              ; preds = %entry, %for.cond.cleanup3
  %indvars.iv21 = phi i64 [ 0, %entry ], [ %indvars.iv.next22, %for.cond.cleanup3 ]
  %0 = mul nuw nsw i64 %indvars.iv21, 10
  br label %for.body4

for.cond.cleanup:                                 ; preds = %for.cond.cleanup3
  %1 = load i32, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
  %add9 = add nsw i32 %1, 3
  ret i32 %add9

for.cond.cleanup3:                                ; preds = %for.body4
  %indvars.iv.next22 = add nuw nsw i64 %indvars.iv21, 1
  %exitcond25.not = icmp eq i64 %indvars.iv.next22, 10
  br i1 %exitcond25.not, label %for.cond.cleanup, label %for.cond1.preheader

for.body4:                                        ; preds = %for.cond1.preheader, %for.body4
  %indvars.iv = phi i64 [ 1, %for.cond1.preheader ], [ %indvars.iv.next, %for.body4 ]
  %2 = mul nuw nsw i64 %indvars.iv, %indvars.iv21
  %3 = add nuw nsw i64 %indvars.iv, %0
  %arrayidx = getelementptr inbounds nuw [101 x i32], ptr @A, i64 0, i64 %3
  %4 = trunc nuw nsw i64 %2 to i32
  store i32 %4, ptr %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 11
  br i1 %exitcond.not, label %for.cond.cleanup3, label %for.body4
}

; Function Attrs: nofree norecurse nosync nounwind ssp memory(readwrite, argmem: none, inaccessiblemem: none) uwtable(sync)
define range(i32 -2147483645, -2147483648) i32 @range_overlap_2d_2b() local_unnamed_addr #0 {
; CHECK: Function Attrs: mustprogress nofree norecurse nosync nounwind willreturn
; CHECK-LABEL: define {{[^@]+}}@range_overlap_2d_2b
; CHECK-SAME: () local_unnamed_addr #[[ATTR1]] {
; CHECK-NEXT:  entry:
; CHECK-NEXT:    store i32 3, ptr @A, align 4
; CHECK-NEXT:    store i32 5, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
; CHECK-NEXT:    br label [[FOR_COND1_PREHEADER:%.*]]
; CHECK:       for.cond1.preheader:
; CHECK-NEXT:    [[INDVARS_IV22:%.*]] = phi i64 [ 0, [[ENTRY:%.*]] ], [ [[INDVARS_IV_NEXT23:%.*]], [[FOR_COND_CLEANUP3:%.*]] ]
; CHECK-NEXT:    [[TMP0:%.*]] = mul nuw nsw i64 [[INDVARS_IV22]], 10
; CHECK-NEXT:    [[TMP1:%.*]] = or disjoint i64 [[TMP0]], 1
; CHECK-NEXT:    br label [[FOR_BODY4:%.*]]
; CHECK:       for.cond.cleanup:
; CHECK-NEXT:    [[TMP2:%.*]] = load i32, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
; CHECK-NEXT:    [[ADD10:%.*]] = add nsw i32 [[TMP2]], 3
; CHECK-NEXT:    ret i32 [[ADD10]]
; CHECK:       for.cond.cleanup3:
; CHECK-NEXT:    [[INDVARS_IV_NEXT23]] = add nuw nsw i64 [[INDVARS_IV22]], 1
; CHECK-NEXT:    [[EXITCOND27_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT23]], 10
; CHECK-NEXT:    br i1 [[EXITCOND27_NOT]], label [[FOR_COND_CLEANUP:%.*]], label [[FOR_COND1_PREHEADER]]
; CHECK:       for.body4:
; CHECK-NEXT:    [[INDVARS_IV:%.*]] = phi i64 [ 0, [[FOR_COND1_PREHEADER]] ], [ [[INDVARS_IV_NEXT:%.*]], [[FOR_BODY4]] ]
; CHECK-NEXT:    [[TMP3:%.*]] = mul nuw nsw i64 [[INDVARS_IV]], [[INDVARS_IV22]]
; CHECK-NEXT:    [[TMP4:%.*]] = add nuw nsw i64 [[TMP1]], [[INDVARS_IV]]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds nuw [101 x i32], ptr @A, i64 0, i64 [[TMP4]]
; CHECK-NEXT:    [[TMP5:%.*]] = trunc nuw nsw i64 [[TMP3]] to i32
; CHECK-NEXT:    store i32 [[TMP5]], ptr [[ARRAYIDX]], align 4
; CHECK-NEXT:    [[INDVARS_IV_NEXT]] = add nuw nsw i64 [[INDVARS_IV]], 1
; CHECK-NEXT:    [[EXITCOND_NOT:%.*]] = icmp eq i64 [[INDVARS_IV_NEXT]], 10
; CHECK-NEXT:    br i1 [[EXITCOND_NOT]], label [[FOR_COND_CLEANUP3]], label [[FOR_BODY4]]
;
entry:
  store i32 3, ptr @A, align 4
  store i32 5, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
  br label %for.cond1.preheader

for.cond1.preheader:                              ; preds = %entry, %for.cond.cleanup3
  %indvars.iv22 = phi i64 [ 0, %entry ], [ %indvars.iv.next23, %for.cond.cleanup3 ]
  %0 = mul nuw nsw i64 %indvars.iv22, 10
  %1 = or disjoint i64 %0, 1
  br label %for.body4

for.cond.cleanup:                                 ; preds = %for.cond.cleanup3
  %2 = load i32, ptr getelementptr inbounds nuw (i8, ptr @A, i64 400), align 4
  %add10 = add nsw i32 %2, 3
  ret i32 %add10

for.cond.cleanup3:                                ; preds = %for.body4
  %indvars.iv.next23 = add nuw nsw i64 %indvars.iv22, 1
  %exitcond27.not = icmp eq i64 %indvars.iv.next23, 10
  br i1 %exitcond27.not, label %for.cond.cleanup, label %for.cond1.preheader

for.body4:                                        ; preds = %for.cond1.preheader, %for.body4
  %indvars.iv = phi i64 [ 0, %for.cond1.preheader ], [ %indvars.iv.next, %for.body4 ]
  %3 = mul nuw nsw i64 %indvars.iv, %indvars.iv22
  %4 = add nuw nsw i64 %1, %indvars.iv
  %arrayidx = getelementptr inbounds nuw [101 x i32], ptr @A, i64 0, i64 %4
  %5 = trunc nuw nsw i64 %3 to i32
  store i32 %5, ptr %arrayidx, align 4
  %indvars.iv.next = add nuw nsw i64 %indvars.iv, 1
  %exitcond.not = icmp eq i64 %indvars.iv.next, 10
  br i1 %exitcond.not, label %for.cond.cleanup3, label %for.body4
}
;.
; CHECK: attributes #[[ATTR0]] = { mustprogress nofree norecurse nosync nounwind willreturn memory(write) }
; CHECK: attributes #[[ATTR1]] = { mustprogress nofree norecurse nosync nounwind willreturn }
;.
;; NOTE: These prefixes are unused and the list is autogenerated. Do not add tests below this line:
; CGSCC: {{.*}}
; TUNIT: {{.*}}
